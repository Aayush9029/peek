#!/bin/bash
#***************************************************************************
#*** peek - describe images from the terminal using vision LLMs
#***************************************************************************

VERSION="0.3.0"

#***** color scheme *****
GREEN='\033[1;32m'
RED='\033[1;31m'
YELLOW='\033[1;33m'
CYAN='\033[1;36m'
BLUE='\033[1;34m'
DIM='\033[2m'
BOLD='\033[1m'
RESET='\033[0m'

#***** set defaults *****
DEFAULT_MODEL="qwen32b"
DEFAULT_DETAIL="normal"
CONTEXT=""
NAME_ONLY=false
RENAME=false
RECURSIVE=false
TIMESTAMP_CONTEXT=false
PARALLEL_JOBS=1

#***** model lookup (bash 3.2 compatible) *****
resolve_model_id() {
    case "$1" in
        qwen32b)  echo "qwen/qwen3-vl-32b-instruct" ;;
        qwen72b)  echo "qwen/qwen3-vl-235b-a22b-instruct" ;;
        llama11b) echo "meta-llama/llama-3.2-11b-vision-instruct" ;;
        gemma12b) echo "google/gemma-3-12b-it" ;;
        *)        return 1 ;;
    esac
}

#***** detail prompt lookup *****
resolve_detail_prompt() {
    case "$1" in
        brief)    echo 'Respond with JSON: {"name": "<2-3 word dash-separated name>", "description": "<1-2 sentences>"}. The name should be lowercase, filename-safe, max 3 words.' ;;
        normal)   echo 'Respond with JSON: {"name": "<2-3 word dash-separated name>", "description": "<short paragraph>"}. The name should be lowercase, filename-safe, max 3 words.' ;;
        detailed) echo 'Respond with JSON: {"name": "<2-3 word dash-separated name>", "description": "<comprehensive description>"}. The name should be lowercase, filename-safe, max 3 words.' ;;
        *)        return 1 ;;
    esac
}

#***** helper functions *****
print_header() {
    echo -e "${CYAN}${BOLD}üëÅ peek${RESET}"
}

print_success() {
    echo -e "${GREEN}‚úì${RESET} $1"
}

print_error() {
    echo -e "${RED}‚úó${RESET} $1" >&2
}

print_status() {
    echo -e "  ${GREEN}‚Üí${RESET} $1"
}

print_dim() {
    echo -e "  ${DIM}$1${RESET}"
}

#***** progress bar *****
print_progress() {
    local current=$1
    local total=$2
    local name="$3"
    local width=30
    local pct=$((current * 100 / total))
    local filled=$((current * width / total))
    local empty=$((width - filled))
    local bar=""
    for ((i=0; i<filled; i++)); do bar+="‚ñà"; done
    for ((i=0; i<empty; i++)); do bar+="‚ñë"; done
    printf "\r  ${YELLOW}%s${RESET} ${DIM}%d/%d${RESET} %s" "$bar" "$current" "$total" "$name" >&2
}

#***** show help *****
function show_help() {
    echo
    print_header
    echo -e "  ${DIM}describe images using vision LLMs${RESET}"
    echo
    echo -e "${BLUE}USAGE${RESET}"
    echo -e "    peek <image-or-dir> [options]"
    echo
    echo -e "${BLUE}OPTIONS${RESET}"
    echo -e "    -h, --help                Show this help"
    echo -e "    -v, --version             Show version"
    echo -e "    -m, --model <name>        Model shorthand (default: $DEFAULT_MODEL)"
    echo -e "    -d, --detail <level>      brief | normal | detailed (default: $DEFAULT_DETAIL)"
    echo -e "    -c, --context <text>      Context to guide the description"
    echo -e "    --name-only               Print only the name (no description)"
    echo -e "    --list-models             List supported models"
    echo
    echo -e "${BLUE}DIRECTORY OPTIONS${RESET}"
    echo -e "    -r, --recursive           Recurse into subdirectories"
    echo -e "    -j, --jobs <n>            Parallel jobs (default: 1)"
    echo -e "    --rename                  Rename files to their peek names"
    echo -e "    --timestamp-context       Auto-add timestamp and neighbor context"
    echo
    echo -e "${BLUE}EXAMPLES${RESET}"
    echo -e "    ${DIM}peek photo.png${RESET}                                  ${DIM}# describe single image${RESET}"
    echo -e "    ${DIM}peek shot.png -m qwen72b -d detailed${RESET}            ${DIM}# detailed with qwen 72B${RESET}"
    echo -e "    ${DIM}peek ui.png -c \"iOS settings screen\"${RESET}            ${DIM}# with context hint${RESET}"
    echo -e "    ${DIM}peek ./screenshots --rename --timestamp-context${RESET}  ${DIM}# rename a directory${RESET}"
    echo -e "    ${DIM}peek ./images -r -j 4 --name-only${RESET}              ${DIM}# parallel recursive${RESET}"
    echo
    echo -e "${DIM}Requires OPENROUTER_API_KEY environment variable.${RESET}"
    echo
    exit 0
}

#***** show version *****
function show_version() {
    echo "peek $VERSION"
    exit 0
}

#***** list models *****
function list_models() {
    echo
    print_header
    echo
    echo -e "${BLUE}SUPPORTED MODELS${RESET}"
    echo
    echo -e "    ${BOLD}Shorthand     Model ID${RESET}"
    echo -e "    ${DIM}‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ     ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ${RESET}"
    echo -e "    qwen32b       qwen/qwen3-vl-32b-instruct ${DIM}(default)${RESET}"
    echo -e "    qwen72b       qwen/qwen3-vl-235b-a22b-instruct"
    echo -e "    llama11b      meta-llama/llama-3.2-11b-vision-instruct"
    echo -e "    gemma12b      google/gemma-3-12b-it"
    echo
    exit 0
}

#***** process a single image (core logic) *****
process_image() {
    local image_path="$1"
    local model_id="$2"
    local system_prompt="$3"
    local extra_context="$4"

    #-- detect MIME type --
    local mime_type
    mime_type=$(file --mime-type -b "$image_path")
    case "$mime_type" in
        image/png|image/jpeg|image/gif|image/webp) ;;
        *)
            print_error "Unsupported image type: $mime_type ($image_path)"
            return 1
            ;;
    esac

    #-- build full prompt --
    local full_prompt="$system_prompt"
    if [[ -n "$extra_context" ]]; then
        full_prompt="${full_prompt} Context: ${extra_context}"
    fi

    #-- build JSON payload to temp file --
    local payload_file
    payload_file=$(mktemp)

    base64 -i "$image_path" | python3 -c "
import json, sys
b64 = sys.stdin.read().replace('\n', '')
payload = {
    'model': sys.argv[1],
    'messages': [{
        'role': 'user',
        'content': [
            {'type': 'text', 'text': sys.argv[2]},
            {'type': 'image_url', 'image_url': {'url': 'data:' + sys.argv[3] + ';base64,' + b64}}
        ]
    }],
    'max_tokens': 1024,
    'provider': {'allow_fallbacks': True}
}
print(json.dumps(payload))
" "$model_id" "$full_prompt" "$mime_type" > "$payload_file"

    #-- call OpenRouter API --
    local response http_code body
    response=$(curl -s -w "\n%{http_code}" \
        -X POST "https://openrouter.ai/api/v1/chat/completions" \
        -H "Content-Type: application/json" \
        -H "Authorization: Bearer $OPENROUTER_API_KEY" \
        -d @"$payload_file")

    rm -f "$payload_file"

    http_code=$(echo "$response" | tail -1)
    body=$(echo "$response" | sed '$d')

    #-- parse response --
    if [[ "$http_code" -ne 200 ]]; then
        local error_msg
        error_msg=$(echo "$body" | python3 -c "
import json, sys
try:
    data = json.load(sys.stdin)
    msg = data.get('error', {}).get('message', 'Unknown error')
    print(msg)
except:
    print('HTTP $http_code')
" 2>/dev/null)
        print_error "API error: $error_msg ($image_path)"
        return 1
    fi

    local parsed
    parsed=$(echo "$body" | python3 -c "
import json, re, sys
try:
    data = json.load(sys.stdin)
    content = data['choices'][0]['message']['content']
    try:
        result = json.loads(content)
    except json.JSONDecodeError:
        m = re.search(r'\`\`\`(?:json)?\s*(\{.*?\})\s*\`\`\`', content, re.DOTALL)
        if m:
            result = json.loads(m.group(1))
        else:
            m = re.search(r'\{.*\}', content, re.DOTALL)
            if m:
                result = json.loads(m.group(0))
            else:
                print(f'No JSON found in response', file=sys.stderr)
                sys.exit(1)
    name = result.get('name', '').strip()
    description = result.get('description', '').strip()
    if not name or not description:
        print('Missing name or description in response', file=sys.stderr)
        sys.exit(1)
    print(name)
    print(description)
except Exception as e:
    print(f'Failed to parse response: {e}', file=sys.stderr)
    sys.exit(1)
")

    if [[ $? -ne 0 ]]; then
        print_error "Failed to parse API response ($image_path)"
        return 1
    fi

    local peek_name peek_description
    peek_name=$(echo "$parsed" | head -1)
    peek_description=$(echo "$parsed" | tail -n +2)

    #-- output --
    if [[ "$NAME_ONLY" == true ]]; then
        echo "$peek_name"
    elif [[ -t 1 ]]; then
        echo -e "  ${BOLD}Name:${RESET} $peek_name"
        echo -e "  ${BOLD}Description:${RESET} $peek_description"
    else
        printf '%s\t%s\n' "$peek_name" "$peek_description"
    fi

    return 0
}

#***** parse arguments *****
model="$DEFAULT_MODEL"
detail="$DEFAULT_DETAIL"
target_path=""

while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            show_help
            ;;
        -v|--version)
            show_version
            ;;
        --list-models)
            list_models
            ;;
        --name-only)
            NAME_ONLY=true
            shift
            ;;
        --rename)
            RENAME=true
            NAME_ONLY=true
            shift
            ;;
        --recursive|-r)
            RECURSIVE=true
            shift
            ;;
        --timestamp-context)
            TIMESTAMP_CONTEXT=true
            shift
            ;;
        -j|--jobs)
            if [[ -z "$2" ]]; then
                print_error "--jobs requires a number"
                exit 1
            fi
            PARALLEL_JOBS="$2"
            shift 2
            ;;
        -m|--model)
            if [[ -z "$2" ]]; then
                print_error "--model requires a model name"
                exit 1
            fi
            model="$2"
            shift 2
            ;;
        -d|--detail)
            if [[ -z "$2" ]]; then
                print_error "--detail requires a level (brief, normal, detailed)"
                exit 1
            fi
            detail="$2"
            shift 2
            ;;
        -c|--context)
            if [[ -z "$2" ]]; then
                print_error "--context requires text"
                exit 1
            fi
            CONTEXT="$2"
            shift 2
            ;;
        -*)
            print_error "Unknown option: $1"
            echo -e "${DIM}Use 'peek --help' for usage${RESET}" >&2
            exit 1
            ;;
        *)
            if [[ -z "$target_path" ]]; then
                target_path="$1"
                shift
            else
                print_error "Unexpected argument: $1"
                exit 1
            fi
            ;;
    esac
done

#***** validate inputs *****
if [[ -z "$target_path" ]]; then
    print_error "No image or directory path provided"
    echo -e "${DIM}Usage: peek <image-or-dir> [options]${RESET}" >&2
    exit 1
fi

model_id=$(resolve_model_id "$model")
if [[ $? -ne 0 ]]; then
    print_error "Unknown model: $model"
    echo -e "${DIM}Use 'peek --list-models' to see available models${RESET}" >&2
    exit 1
fi

system_prompt=$(resolve_detail_prompt "$detail")
if [[ $? -ne 0 ]]; then
    print_error "Unknown detail level: $detail (use brief, normal, or detailed)"
    exit 1
fi

if [[ -z "$OPENROUTER_API_KEY" ]]; then
    print_error "OPENROUTER_API_KEY environment variable not set"
    echo -e "${DIM}Get a key at https://openrouter.ai/keys${RESET}" >&2
    exit 1
fi

#***** single file mode *****
if [[ -f "$target_path" ]]; then
    if [[ -t 1 ]]; then
        echo
        print_header
        print_dim "v${VERSION} ¬∑ https://github.com/Aayush9029/peek"
        echo
        print_status "Image: ${BOLD}$(basename "$target_path")${RESET}"
        print_status "Model: ${BOLD}${model}${RESET} ${DIM}(${model_id})${RESET}"
        print_status "Detail: ${BOLD}${detail}${RESET}"
        [[ -n "$CONTEXT" ]] && print_status "Context: ${BOLD}${CONTEXT}${RESET}"
        echo
        echo -ne "  ${YELLOW}‚è≥${RESET} Thinking..."
    fi

    extra_context="$CONTEXT"
    result=$(process_image "$target_path" "$model_id" "$system_prompt" "$extra_context")
    exit_code=$?

    if [[ -t 1 ]]; then
        echo -ne "\r\033[K"
    fi

    if [[ $exit_code -eq 0 ]]; then
        echo "$result"

        #-- rename if requested --
        if [[ "$RENAME" == true && -n "$result" ]]; then
            safe=$(echo "$result" | head -1 | sed 's/\x1b\[[0-9;]*m//g' | LC_ALL=C tr -dc 'a-zA-Z0-9 _-' | sed 's/^ *//;s/ *$//' | tr ' ' '-' | tr '[:upper:]' '[:lower:]' | cut -c1-80)
            if [[ -n "$safe" ]]; then
                ext="${target_path##*.}"
                dir=$(dirname "$target_path")
                newpath="${dir}/${safe}.${ext}"
                if [[ "$newpath" != "$target_path" ]]; then
                    # handle duplicates
                    if [[ -f "$newpath" ]]; then
                        i=2
                        while [[ -f "${dir}/${safe}-${i}.${ext}" ]]; do
                            i=$((i+1))
                        done
                        newpath="${dir}/${safe}-${i}.${ext}"
                    fi
                    mv "$target_path" "$newpath"
                    if [[ -t 1 ]]; then
                        print_success "Renamed ‚Üí $(basename "$newpath")"
                        echo
                    fi
                fi
            fi
        elif [[ -t 1 ]]; then
            echo
        fi
    fi
    exit $exit_code
fi

#***** directory mode *****
if [[ ! -d "$target_path" ]]; then
    print_error "Not a file or directory: $target_path"
    exit 1
fi

# collect image files
image_files=()
if [[ "$RECURSIVE" == true ]]; then
    while IFS= read -r -d '' f; do
        image_files+=("$f")
    done < <(find "$target_path" -type f \( -iname "*.png" -o -iname "*.jpg" -o -iname "*.jpeg" -o -iname "*.gif" -o -iname "*.webp" \) -print0 | sort -z)
else
    while IFS= read -r -d '' f; do
        image_files+=("$f")
    done < <(find "$target_path" -maxdepth 1 -type f \( -iname "*.png" -o -iname "*.jpg" -o -iname "*.jpeg" -o -iname "*.gif" -o -iname "*.webp" \) -print0 | sort -z)
fi

total=${#image_files[@]}
if [[ $total -eq 0 ]]; then
    print_error "No images found in $target_path"
    exit 1
fi

# build timestamp map for --timestamp-context
declare -a file_timestamps
if [[ "$TIMESTAMP_CONTEXT" == true ]]; then
    for ((i=0; i<total; i++)); do
        file_timestamps[$i]=$(stat -f "%Sm" -t "%Y-%m-%d %H:%M" "${image_files[$i]}" 2>/dev/null)
    done
fi

if [[ -t 1 ]]; then
    echo
    print_header
    print_dim "v${VERSION} ¬∑ https://github.com/Aayush9029/peek"
    echo
    print_status "Directory: ${BOLD}${target_path}${RESET}"
    print_status "Images: ${BOLD}${total}${RESET}"
    print_status "Model: ${BOLD}${model}${RESET} ${DIM}(${model_id})${RESET}"
    print_status "Jobs: ${BOLD}${PARALLEL_JOBS}${RESET}"
    [[ "$RENAME" == true ]] && print_status "Mode: ${BOLD}rename${RESET}"
    [[ "$TIMESTAMP_CONTEXT" == true ]] && print_status "Timestamp context: ${BOLD}enabled${RESET}"
    echo
fi

#***** process single image in directory mode *****
process_dir_image() {
    local idx=$1
    local f="${image_files[$idx]}"
    local basename_f
    basename_f=$(basename "$f")

    # build context
    local extra_context="$CONTEXT"

    if [[ "$TIMESTAMP_CONTEXT" == true ]]; then
        local ts="${file_timestamps[$idx]}"
        local ts_ctx="Screenshot taken at ${ts}."

        # gather neighbors (within 2 indices)
        local neighbors=""
        for ((j=idx-2; j<=idx+2; j++)); do
            if [[ $j -ge 0 && $j -lt $total && $j -ne $idx ]]; then
                local nname
                nname=$(basename "${image_files[$j]}")
                local nts="${file_timestamps[$j]}"
                neighbors="${neighbors}${nts} ${nname}, "
            fi
        done

        ts_ctx="${ts_ctx}"
        if [[ -n "$neighbors" ]]; then
            ts_ctx="${ts_ctx} Nearby screenshots: ${neighbors%, }"
        fi

        if [[ -n "$extra_context" ]]; then
            extra_context="${extra_context}. ${ts_ctx}"
        else
            extra_context="$ts_ctx"
        fi
    fi

    local result
    result=$(process_image "$f" "$model_id" "$system_prompt" "$extra_context")
    local exit_code=$?

    if [[ $exit_code -ne 0 ]]; then
        echo "FAIL	${f}" >> "$results_file"
        return 1
    fi

    local peek_name
    peek_name=$(echo "$result" | head -1)

    # rename if requested
    if [[ "$RENAME" == true && -n "$peek_name" ]]; then
        local safe
        safe=$(echo "$peek_name" | sed 's/\x1b\[[0-9;]*m//g' | LC_ALL=C tr -dc 'a-zA-Z0-9 _-' | sed 's/^ *//;s/ *$//' | tr ' ' '-' | tr '[:upper:]' '[:lower:]' | cut -c1-80)
        if [[ -n "$safe" ]]; then
            local ext="${f##*.}"
            local dir
            dir=$(dirname "$f")
            local newpath="${dir}/${safe}.${ext}"
            if [[ "$newpath" != "$f" ]]; then
                # handle duplicates
                if [[ -f "$newpath" ]]; then
                    local i=2
                    while [[ -f "${dir}/${safe}-${i}.${ext}" ]]; do
                        i=$((i+1))
                    done
                    newpath="${dir}/${safe}-${i}.${ext}"
                fi
                mv "$f" "$newpath"
                echo "RENAME	$(basename "$f")	$(basename "$newpath")" >> "$results_file"
            else
                echo "SAME	$(basename "$f")" >> "$results_file"
            fi
        fi
    else
        echo "OK	${f}	${result}" >> "$results_file"
    fi
}

# results tracking
results_file=$(mktemp)
trap "rm -f '$results_file'" EXIT

completed=0
failed=0

if [[ $PARALLEL_JOBS -gt 1 ]]; then
    #***** parallel processing *****
    active_pids=()

    for ((idx=0; idx<total; idx++)); do
        # wait if we've hit the job limit
        while [[ ${#active_pids[@]} -ge $PARALLEL_JOBS ]]; do
            # wait for any one to finish
            for p_idx in "${!active_pids[@]}"; do
                if ! kill -0 "${active_pids[$p_idx]}" 2>/dev/null; then
                    wait "${active_pids[$p_idx]}" 2>/dev/null
                    unset "active_pids[$p_idx]"
                    active_pids=("${active_pids[@]}")
                    completed=$((completed + 1))
                    if [[ -t 1 ]]; then
                        print_progress $completed $total "$(basename "${image_files[$idx]}")"
                    fi
                    break
                fi
            done
            sleep 0.1
        done

        process_dir_image "$idx" &
        active_pids+=($!)
    done

    # wait for remaining
    for pid in "${active_pids[@]}"; do
        wait "$pid" 2>/dev/null
        completed=$((completed + 1))
        if [[ -t 1 ]]; then
            print_progress $completed $total ""
        fi
    done
else
    #***** sequential processing *****
    for ((idx=0; idx<total; idx++)); do
        if [[ -t 1 ]]; then
            print_progress $((idx + 1)) $total "$(basename "${image_files[$idx]}")"
        fi
        process_dir_image "$idx"
    done
fi

if [[ -t 1 ]]; then
    echo -ne "\r\033[K"  # clear progress line
fi

#***** print results summary *****
renamed_count=$(grep -c "^RENAME" "$results_file" 2>/dev/null || echo 0)
same_count=$(grep -c "^SAME" "$results_file" 2>/dev/null || echo 0)
fail_count=$(grep -c "^FAIL" "$results_file" 2>/dev/null || echo 0)
ok_count=$(grep -c "^OK" "$results_file" 2>/dev/null || echo 0)

if [[ -t 1 ]]; then
    echo
    if [[ "$RENAME" == true ]]; then
        # show renames
        while IFS=$'\t' read -r status old new; do
            if [[ "$status" == "RENAME" ]]; then
                echo -e "  ${GREEN}‚úì${RESET} ${DIM}${old}${RESET} ‚Üí ${BOLD}${new}${RESET}"
            elif [[ "$status" == "SAME" ]]; then
                echo -e "  ${DIM}¬∑ ${old} (unchanged)${RESET}"
            elif [[ "$status" == "FAIL" ]]; then
                echo -e "  ${RED}‚úó${RESET} ${old}"
            fi
        done < "$results_file"
        echo
        print_success "${renamed_count} renamed, ${same_count} unchanged, ${fail_count} failed"
    else
        # show descriptions
        while IFS=$'\t' read -r status path rest; do
            if [[ "$status" == "OK" ]]; then
                echo -e "  ${BOLD}$(basename "$path")${RESET}: ${rest}"
            elif [[ "$status" == "FAIL" ]]; then
                echo -e "  ${RED}‚úó${RESET} $(basename "$path"): failed"
            fi
        done < "$results_file"
        echo
        print_success "${ok_count} processed, ${fail_count} failed"
    fi
    echo
fi

rm -f "$results_file"
